@page "/"

@inject IJSRuntime JS
@using Microsoft.AspNetCore.Components.Web
<link
    href="https://cdn.jsdelivr.net/npm/bootswatch@5.3.3/dist/lux/bootstrap.min.css"
    rel="stylesheet"
/>

<h2 class="title">📝 My ToDo</h2>

<div class="container">
    <form class="add-row" @onsubmit="AddTask">
        <input
            class="add-input"
            placeholder="Додати задачу та натиснути Enter..."
            @bind="newTask"
            @bind:event="oninput"
            aria-label="Нова задача" />
        <button type="submit" class="add-btn">Додати</button>
    </form>

    <div class="controls">
        <div class="filters">
            <button class='@FilterButtonClass("all")' @onclick='() => SetFilter("all")'>Усі</button>
            <button class='@FilterButtonClass("active")' @onclick='() => SetFilter("active")'>Активні</button>
            <button class='@FilterButtonClass("done")' @onclick='() => SetFilter("done")'>Виконані</button>
        </div>

        <div class="actions">
            <span class="muted">Залишилось: @tasks.Count(t => !t.Done)</span>
            <button class="small" @onclick="ClearCompleted">Видалити виконані</button>
            <button class="small outline" @onclick="ClearAll">Видалити все</button>
        </div>
    </div>

    <ul class="todo-list"
        @ondragover:preventDefault="true"
        @ondrop="OnDropOnList">
        @if (FilteredTasks.Count == 0)
        {
            <li class="empty">Немає задач</li>
        }
        else
        {
            @foreach (var t in FilteredTasks)
            {
                <!-- important: ondragstart calls JS to set dataTransfer and window._todoDraggedId -->
                <li class='todo-item @(draggedId == t.Id ? "dragging" : "")'
                    draggable="true"
                    ondragstart="todoDnd.onDragStart(event, '@t.Id')"
                    @ondragenter='(e) => OnDragEnter(e, t.Id)'
                    @ondragover:preventDefault="true"
                    @ondrop='(e) => OnDropOnItem(e, t.Id)'>

                    <div class="left">
                        <input type="checkbox" checked="@t.Done" @onclick='() => ToggleDone(t)' aria-label="Позначити" />
                    </div>

                    <div class="middle">
                        @if (editingId == t.Id)
                        {
                            <input class="edit-input" @bind="editingText" @bind:event="oninput"
                                   @onkeydown='(e) => EditKeyDown(e, t.Id)'
                                   @onblur='() => SaveEdit(t.Id)' autofocus />
                        }
                        else
                        {
                            <div class="text" @ondblclick='() => StartEdit(t)'>@t.Text</div>
                            <div class="meta">@t.CreatedAt.ToString("g")</div>
                        }
                    </div>

                    <div class="right">
                        <button class="icon" title="Редагувати" @onclick='() => StartEdit(t)'>✏️</button>
                        <button class="icon" title="Видалити" @onclick='() => RemoveTask(t)'>🗑️</button>
                        <span class="handle" title="Перетягни">⋮⋮</span>
                    </div>
                </li>
            }
        }
    </ul>

    <div class="footer">Всього: @tasks.Count</div>
</div>

@code {
    private const string STORAGE_KEY = "todo-list-v1";
    private string newTask = "";
    private List<TaskItem> tasks = new();
    private string? draggedId;
    private string? dragOverId;
    private string filter = "all";

    private string? editingId;
    private string editingText = "";

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var json = await JS.InvokeAsync<string>("localStorage.getItem", STORAGE_KEY);
            if (!string.IsNullOrEmpty(json))
            {
                tasks = System.Text.Json.JsonSerializer.Deserialize<List<TaskItem>>(json) ?? new();
            }
        }
        catch
        {
            tasks = new();
        }
    }

    private List<TaskItem> FilteredTasks =>
        filter switch
        {
            "active" => tasks.Where(t => !t.Done).ToList(),
            "done" => tasks.Where(t => t.Done).ToList(),
            _ => tasks
        };

    private string FilterButtonClass(string key) => filter == key ? "filter-btn active" : "filter-btn";

    private async Task AddTask()
    {
        if (string.IsNullOrWhiteSpace(newTask)) return;
        var item = new TaskItem
        {
            Id = Guid.NewGuid().ToString("N"),
            Text = newTask.Trim(),
            Done = false,
            CreatedAt = DateTime.Now
        };
        tasks.Insert(0, item);
        newTask = "";
        await SaveTasks();
    }

    private async Task RemoveTask(TaskItem t)
    {
        tasks.RemoveAll(x => x.Id == t.Id);
        await SaveTasks();
    }

    private async Task ToggleDone(TaskItem t)
    {
        t.Done = !t.Done;
        await SaveTasks();
    }

    private void SetFilter(string f) => filter = f;

    private async Task ClearCompleted()
    {
        tasks = tasks.Where(t => !t.Done).ToList();
        await SaveTasks();
    }

    private async Task ClearAll()
    {
        if (await Confirm("Видалити всі задачі?"))
        {
            tasks.Clear();
            await SaveTasks();
        }
    }

    // --- Drag & Drop helpers ---
    // OnDragEnter is only for visual state
    private void OnDragEnter(DragEventArgs e, string id)
    {
        dragOverId = id;
    }

    // When dropped on an item - get dragged id from JS fallback and reorder
    private async Task OnDropOnItem(DragEventArgs e, string targetId)
    {
        // try to get id from dataTransfer first (if available)
        string? dragged = null;

        try
        {
            // attempt to read from DataTransfer (may be null in some browsers when using Blazor)
            if (e?.DataTransfer != null)
            {
                // some browsers support GetData with 'text/plain'
                try
                {
#if NET6_0_OR_GREATER
                    // DataTransfer API in DragEventArgs might expose GetData in some runtimes, but it's safer to use JS fallback
#endif
                }
                catch { }
            }
        }
        catch { }

        // fallback: ask JS global var set by ondragstart
        try
        {
            var fromJs = await JS.InvokeAsync<string>("todoDnd.getDraggedId");
            if (!string.IsNullOrEmpty(fromJs))
            {
                dragged = fromJs;
                // clear global
                await JS.InvokeVoidAsync("todoDnd.clearDraggedId");
            }
        }
        catch { }

        // if still null then nothing to do
        if (string.IsNullOrEmpty(dragged) || dragged == targetId) { draggedId = null; dragOverId = null; return; }

        var draggedIndex = tasks.FindIndex(t => t.Id == dragged);
        var targetIndex = tasks.FindIndex(t => t.Id == targetId);
        if (draggedIndex < 0 || targetIndex < 0) { draggedId = null; dragOverId = null; return; }

        var item = tasks[draggedIndex];
        tasks.RemoveAt(draggedIndex);

        // insert before target
        var insertIndex = targetIndex;
        tasks.Insert(insertIndex, item);

        draggedId = null;
        dragOverId = null;

        await SaveTasks();
    }

    private async Task OnDropOnList()
    {
        // fallback: get draggedId from JS
        var dragged = await JS.InvokeAsync<string>("todoDnd.getDraggedId");
        await JS.InvokeVoidAsync("todoDnd.clearDraggedId");

        if (string.IsNullOrEmpty(dragged)) return;

        var draggedIndex = tasks.FindIndex(t => t.Id == dragged);
        if (draggedIndex < 0) return;
        var item = tasks[draggedIndex];
        tasks.RemoveAt(draggedIndex);
        tasks.Add(item);

        draggedId = null;
        dragOverId = null;
        await SaveTasks();
    }

    // --- Inline edit ---
    private void StartEdit(TaskItem t)
    {
        editingId = t.Id;
        editingText = t.Text;
    }

    private async Task SaveEdit(string id)
    {
        if (string.IsNullOrWhiteSpace(editingText))
        {
            tasks.RemoveAll(x => x.Id == id);
        }
        else
        {
            var it = tasks.FirstOrDefault(x => x.Id == id);
            if (it != null) it.Text = editingText.Trim();
        }
        editingId = null;
        editingText = "";
        await SaveTasks();
    }

    private void EditKeyDown(KeyboardEventArgs e, string id)
    {
        if (e.Key == "Enter") _ = SaveEdit(id);
        if (e.Key == "Escape") { editingId = null; editingText = ""; }
    }

    // --- Persistence ---
    private async Task SaveTasks()
    {
        try
        {
            var json = System.Text.Json.JsonSerializer.Serialize(tasks);
            await JS.InvokeVoidAsync("localStorage.setItem", STORAGE_KEY, json);
            StateHasChanged();
        }
        catch
        {
        }
    }

    private async Task<bool> Confirm(string message)
    {
        return await JS.InvokeAsync<bool>("confirm", message);
    }

    public class TaskItem
    {
        public string Id { get; set; } = Guid.NewGuid().ToString("N");
        public string Text { get; set; } = "";
        public bool Done { get; set; } = false;
        public DateTime CreatedAt { get; set; } = DateTime.Now;
    }
}
